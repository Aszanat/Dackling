-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelDackling where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified AbsDackling

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: AbsDackling.Ident -> Result
transIdent x = case x of
  AbsDackling.Ident string -> failure x

transInstructions :: Show a => AbsDackling.Instructions' a -> Result
transInstructions x = case x of
  AbsDackling.Program _ instrs -> failure x

transInstr :: Show a => AbsDackling.Instr' a -> Result
transInstr x = case x of
  AbsDackling.ExprInstr _ expr -> failure x
  AbsDackling.DefInstr _ def -> failure x

transDef :: Show a => AbsDackling.Def' a -> Result
transDef x = case x of
  AbsDackling.FunDef _ type_ ident idents expr -> failure x

transExpr :: Show a => AbsDackling.Expr' a -> Result
transExpr x = case x of
  AbsDackling.EInt _ integer -> failure x
  AbsDackling.ETrue _ -> failure x
  AbsDackling.EFalse _ -> failure x
  AbsDackling.EVar _ ident -> failure x
  AbsDackling.ELExp _ lam -> failure x
  AbsDackling.EEmpty _ -> failure x
  AbsDackling.EList _ exprs -> failure x
  AbsDackling.EListAdd _ expr1 expr2 -> failure x
  AbsDackling.ENeg _ expr -> failure x
  AbsDackling.ENot _ expr -> failure x
  AbsDackling.ECallFun _ ident exprs -> failure x
  AbsDackling.ECallLam _ lam exprs -> failure x
  AbsDackling.EMul _ expr1 mulop expr2 -> failure x
  AbsDackling.EAdd _ expr1 addop expr2 -> failure x
  AbsDackling.EOr _ expr1 expr2 -> failure x
  AbsDackling.EAnd _ expr1 expr2 -> failure x
  AbsDackling.ERel _ expr1 relop expr2 -> failure x
  AbsDackling.ELet _ type_ ident idents expr1 expr2 -> failure x
  AbsDackling.EIf _ expr1 expr2 expr3 -> failure x
  AbsDackling.EMatch _ ident pats -> failure x

transLam :: Show a => AbsDackling.Lam' a -> Result
transLam x = case x of
  AbsDackling.ELFun _ type_ idents expr -> failure x

transPat :: Show a => AbsDackling.Pat' a -> Result
transPat x = case x of
  AbsDackling.PEmpty _ expr -> failure x
  AbsDackling.PList _ ident1 ident2 expr -> failure x

transType :: Show a => AbsDackling.Type' a -> Result
transType x = case x of
  AbsDackling.Int _ -> failure x
  AbsDackling.Bool _ -> failure x
  AbsDackling.FunType _ type_1 type_2 -> failure x
  AbsDackling.FunArg _ type_1 type_2 -> failure x
  AbsDackling.LiType _ type_ -> failure x
  AbsDackling.Any _ -> failure x

transAddOp :: Show a => AbsDackling.AddOp' a -> Result
transAddOp x = case x of
  AbsDackling.Plus _ -> failure x
  AbsDackling.Minus _ -> failure x

transMulOp :: Show a => AbsDackling.MulOp' a -> Result
transMulOp x = case x of
  AbsDackling.Times _ -> failure x
  AbsDackling.Div _ -> failure x
  AbsDackling.Mod _ -> failure x

transRelOp :: Show a => AbsDackling.RelOp' a -> Result
transRelOp x = case x of
  AbsDackling.LTH _ -> failure x
  AbsDackling.LE _ -> failure x
  AbsDackling.GTH _ -> failure x
  AbsDackling.GE _ -> failure x
  AbsDackling.EQU _ -> failure x
  AbsDackling.NE _ -> failure x
