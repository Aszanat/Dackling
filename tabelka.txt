Język Dackling
Wzorowany na OCamlu, wymaga podania całego typu funkcji przed jej definicją,
za to nie podaje się typów przy agrumentach.
Pomysł jest taki, że chcę wszystko traktować jak funkcję, a w języku istnieją instrukcje:
-> funkcje, które się ewaluuje/używa/oblicza/aplikuje (i wynik wypisuje się na wyjście standardowe)
-> definicje funkcji, których potem można dalej używać
I nic więcej. A więc np. 3 jest funkcją, która zwraca liczbę 3,
a każdy identyfikator oznacza jakąś funkcję, wprowadzoną poprzez definicję.
Na 20 punktów
+ 01 (dwa typy)
+ 02 (arytmetyka, porównania)
+ 03 (if)
+ 04 (funkcje wieloargumentowe, rekurencja)
+ 05 (funkcje anonimowe i wyższego rzędu, częściowa aplikacja)
+ 06 (obsługa błędów wykonania)
+ 07 (statyczne wiązanie identyfikatorów)
Listy:
+ 08 (z pattern matchingiem)
09 (z empty, head, tail)
+ 10 (lukier)
Na 25 punktów
+ 11 (listy dowolnego typu, zagnieżdżone i listy funkcji)
12 (proste typy algebraiczne z jednopoziomowym pattern matchingiem)
+ 13 (statyczne typowanie)
Na 30 punktów
14 (ogólne polimorficzne i rekurencyjne typy algebraiczne)
15 (zagnieżdżony pattern matching)
Bonus
16 (typy polimorficzne z algorytmem rekonstrukcji typów)
17 (sprawdzenie kompletności pattern matchingu)
Razem: 25